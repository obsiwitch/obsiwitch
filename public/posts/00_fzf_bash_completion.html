<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="robots" content="noindex, nofollow, noarchive" />
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Obsidienne - Fuzzy bash completion</title>
    <link rel="stylesheet" href="/assets/style.css">
</head>

<body>
<main>
<header>
<a href="/">
    <svg class="icon"><use href="/assets/feather.svg#hexagon"/></svg>bsidienne
</a>
</header>

<article>

<header>
<h1>Fuzzy bash completion</h1>
<time>2019-06-02</time>
</header>

<nav>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#script"><span class="toc-section-number">2</span> Script</a></li>
</ul>
</nav>

<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p><a href="https://github.com/junegunn/fzf">Fzf</a> is a command-line fuzzy finder. Some scripts are shipped with fzf to add <a href="https://github.com/junegunn/fzf#key-bindings-for-command-line">keybindings</a> and <a href="https://github.com/junegunn/fzf#fuzzy-completion-for-bash-and-zsh">fuzzy completion</a> to a shell. To use them in bash you can source them in your <code>~/.bashrc</code>.</p>
<p>The <a href="https://github.com/junegunn/fzf/blob/0030d184481686384676537857614977e1fd2f94/shell/completion.bash">bash fuzzy completion script</a> first saves existing completion specifications, e.g. functions defined by the <a href="https://github.com/scop/bash-completion">bash-completion</a> package. Then, it replaces the original specifications with new ones using the <a href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html">complete</a> builtin (e.g. <code>complete -F _fzf_path_completion cd</code>).</p>
<p>If the <code>**</code> trigger sequence is found, fuzzy completion is used (e.g. <code>cd ../**&lt;TAB&gt;</code>). Else, the original completion function for the corresponding command is used (e.g. <code>cd &lt;TAB&gt;</code>).</p>
<p>Doing things this way means only a few commands support fuzzy completion, and other commands need to be added <a href="https://github.com/junegunn/fzf#supported-commands">manually</a> using complete.</p>
<h1 id="script"><span class="header-section-number">2</span> Script</h1>
<p>I wanted fuzzy path completion for every commands and to keep the ability to call the default bash completion, so I wrote my own script.</p>
<p>I could not use the complete builtin with a completion function since we saw it forces us to write a specification for each command we want to use. I could not access the <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html#index-COMP_005fCWORD"><code>COMP_*</code></a> shell variables inside my script either. Keybindings in bash are created using the <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-bind">bind</a> builtin. We can bind our own shell command using <code>bind -x '"keyseq": "shell-command"'</code>. Binding a shell function this way gives us access to the <code>READLINE_LINE</code> and <code>READLINE_POINT</code> variables inside it, allowing us to access the line currently typed in the shell without using the <code>COMP_*</code> variables.</p>
<blockquote>
<pre><code>READLINE_LINE
    The contents of the readline line buffer, for use with &quot;bind -x&quot;
    (see SHELL BUILTIN COMMANDS below).

READLINE_POINT
    The position of the insertion point in the readline line buffer,
    for use with &quot;bind -x&quot; (see SHELL BUILTIN COMMANDS below).</code></pre>
<a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html#index-READLINE_005fLINE">Bash Reference manual - Shell Variables</a>
</blockquote>
<p>I also needed to find a way to call readline’s completion without having to manually call a completion function. To do this we can bind the complete readline function to the <code>\e[0n</code> key sequence (VT100 ANSI escape sequence for <code>Response: terminal is OK</code>). Then we print <code>\e[5n</code> (VT100 ANSI escape sequence for <code>Device status report</code>). The terminal then answers with <code>\e[0n</code>, which in turns activates readline’s completion. <a href="https://unix.stackexchange.com/a/217390">[1]</a></p>
<p>You can find below a minimal version of the script. The full version is available <a href="https://gitlab.com/Obsidienne/dotfiles/blob/6b4c389cf62b62d4fc3448586480c1cc58c3419a/cli/shell/fzf.sh">here</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="co"># Minimal fuzzy completion on trigger sequence &#39;@&#39;, else use readline&#39;s</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co"># completion.</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">function</span><span class="fu"> _fzf_complete()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="bu">local</span> <span class="va">words=(</span> <span class="va">${READLINE_LINE:0:$READLINE_POINT}</span> <span class="va">)</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="bu">local</span> <span class="va">remainder=(</span> <span class="va">${READLINE_LINE:$READLINE_POINT}</span> <span class="va">)</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="kw">if [[</span> <span class="st">&quot;</span><span class="va">${words[-1]:0:1}</span><span class="st">&quot;</span> <span class="ot">!=</span> <span class="st">&#39;@&#39;</span><span class="kw"> ]]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="bu">bind</span> <span class="st">&#39;&quot;\e[0n&quot;: complete&#39;</span><span class="kw">;</span> <span class="bu">printf</span> <span class="st">&#39;\e[5n&#39;</span></a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="bu">return</span></a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="kw">fi</span></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="bu">unset</span> <span class="st">&#39;words[-1]&#39;</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13">    <span class="bu">local</span> <span class="va">selected=$(</span></a>
<a class="sourceLine" id="cb2-14" title="14">        <span class="ex">fd</span> . --print0 \</a>
<a class="sourceLine" id="cb2-15" title="15">        <span class="kw">|</span> <span class="ex">fzf</span> --reverse --multi --read0 --print0 --exit-0 \</a>
<a class="sourceLine" id="cb2-16" title="16">        <span class="kw">|</span> <span class="fu">xargs</span> -0 --no-run-if-empty printf <span class="st">&#39;%q &#39;</span></a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="va">)</span></a>
<a class="sourceLine" id="cb2-18" title="18">    [[ <span class="ex">-z</span> <span class="st">&quot;</span><span class="va">$selected</span><span class="st">&quot;</span> ]] <span class="kw">&amp;&amp;</span> <span class="bu">return</span></a>
<a class="sourceLine" id="cb2-19" title="19"></a>
<a class="sourceLine" id="cb2-20" title="20">    <span class="va">READLINE_LINE=</span><span class="st">&quot;</span><span class="va">${words[*]}</span><span class="st"> </span><span class="va">${selected}${remainder[*]}</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb2-21" title="21">    <span class="va">READLINE_POINT=$((</span> <span class="va">$READLINE_POINT</span> + <span class="va">${#selected}</span> <span class="va">))</span></a>
<a class="sourceLine" id="cb2-22" title="22"><span class="kw">}</span></a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24"><span class="co"># bind _fzf_complete to &lt;TAB&gt;</span></a>
<a class="sourceLine" id="cb2-25" title="25"><span class="bu">bind</span> -x <span class="st">&#39;&quot;\C-i&quot;: &quot;_fzf_complete&quot;&#39;</span></a></code></pre></div>

</article>

</main>
</body>

</html>
